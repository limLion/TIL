# 2진수 연산

## ALU (Arithmetic Logic Unit)

> 산술 논리 연산 장치 (1장 설명)
> 
- Add / Subtract: 덧셈과 뺄셈 연산을 수행한다.
- Carry / Borrow: 덧셈 연산에서, 두 이진수를 더한 결과가 2의 보수를 넘어가는 경우 1을 전달합니다. 이를 캐리(Carry)라고 하며, 뺄셈 연산에서는 대신 빌림(Borrow)이라는 용어를 사용합니다. 
예를 들어, 1 + 1의 결과는 10(2)이므로 캐리가 발생합니다.
- Overflow / Underflow: 연산 결과가 이진수로 표현 가능한 범위를 초과하는 경우 발생하는 오류
- AND / OR: 논리 연산을 수행하는 AND와 OR 연산이 있습니다. 논리 연산은 주로 비트 필드에서 특정 비트를 검사하거나 수정할 때 사용됩니다.

## Interrupt (인터럽트)

> MIPS에서 프로세서 외부로부터 발생하는 예외
> 
- 일반적으로 인터럽트는 하드웨어적인 이벤트에서 발생
ex)입출력(I/O) 작업 완료, 타이머 인터럽트
- 인터럽트는 소프트웨어적인 이벤트에서도 발생할 수 있고 예외(Exception)라고 한다.

## Multiply(곱셈) & Divide(나눗셈)

> 두 개의 레지스터 값을 가져와서 **하드웨어**에서 곱셈, 나눗셈을 수행하고 결과를 다시 레지스터에 저장
> 

### Unroll the loop (순환문)

> 반복문 안에 있는 연산을 반복문을 펼쳐서 여러 개의 독립적인 연산으로 변환하는 것
> 
- 반복 횟수를 미리 알고 있을 때, 연산을 빠르게 수행하기 위해 사용된다.

예를 들어, 32비트 곱셈 연산에서 일반적으로 32번의 반복문을 수행해야 하지만, Unroll the loop 기법을 사용하면 반복문을 4개의 연산으로 전개할 수 있으며, 각각의 연산은 8비트씩 수행됩니다. 이렇게 하면 반복문을 수행하는데 걸리는 시간이 줄어들어 연산 속도를 향상시킬 수 있습니다.

## Divide(나누다) & Conquer(해결)

> 문제를 작은 부분으로 나누어 해결하는 알고리즘 설계 기법
문제를 해결하는 기본방식으로 큰 문제를 해결하려면 작은 문제 여러 개로 분할해서 해결한다.
> 

큰 문제를 작은 부분 문제로 분할하여 각각의 문제를 해결하고, 
그 결과를 조합해 원래 문제를 해결하는 알고리즘 설계 방법

### Divide et impera

마키아벨리의 '군주론'에서 사용되는 말로, 적군을 나누어서 지배하여 더 쉽게 승리하는 전략

Divide & Conquer와 유사한 방법으로 문제를 작은 부분 문제로 분할하여 해결하는 방식

### Divide and rule

여러 개체나 그룹을 작은 단위로 나누어 각각을 지배하면서 더 쉽게 제어하거나 정복하는 전략

Divide & Conquer와 유사한 방식으로 문제를 나누어 해결하는 방법

### MECE

상호 배타적이면서 모든 경우를 포함하는 것을 의미
알고리즘에서는 일반적으로 사용되지는 않지만, 프로그래밍이나 데이터 분석에서 유용하게 사용한다.

## 부동소수점 (Floating Point)

> 소수점을 고정하지 않고 가수(소수)와 지수를 사용하여 실수를 표현하는 방식
> 

ex) 123.456을 부동소수점으로 표현 = 1.23456 x 10^2

- 가수(소수)(mantissa): 0.10011000101100010100011110101110000101111110011011
- 지수(exponent): 6 (2의 6승)

값의 범위와 정밀도가 제한되어 있지 않아, 더 넓은 범위와 높은 정밀도의 값을 표현할 수 있다. 
하지만 연산이 복잡하고 처리 속도가 느린 단점이 있다.

유효수자(Effective Digits)는 소수점 이하의 숫자 중, 실제로 유효한 숫자의 개수를 의미한다. 
ex) 0.9999999999와 같이 0이 아닌 숫자가 많지만, 실제로는 1에 가까운 값이다. 
→ 유효숫자 10개 이상이기 때문에, 1로 어림하여 처리할 수 있다.

### 고정소수점 (Fixed Point) (ppt엔 없음)

> 소수점 이하 자릿수를 고정시킨 표현 방식으로, 표현 가능한 범위가 고정되어 있다.
정밀한 연산이 필요한 과학과 공학 분야에서 많이 사용된다.
> 

ex) 16비트의 고정소수점으로는 소수점 이하 8자리를 표현할 수 있으며, 이때는 값의 범위가 -128부터 127.996875까지로 제한

정수 연산에 사용되며, 고정된 자릿수로 인해 연산이 빠르고 효율적이다.
하지만 값의 범위와 정밀도가 제한되어 있어, 실수를 정확히 표현하지 못하고 오차가 발생할 수 있다.

### 부동소수점 (IEEE 754)

> IEEE 754 부동소수점 표준은 부동소수점 수를 저장하기 위한 이진 형식을 정의한다.
> 

부동소수점(IEEE 754)에서는 수를 표현하는 방법에 따라 단정밀도(float)와 배정밀도(double) 두 가지 형태가 있다. 

### Float (단정밀도) & Double (배정밀도)

단정밀도와 배정밀도 부호, 지수, 가수 세 부분으로 구성되고 가수 부분은 유효숫자를 나타내고, 지수 부분은 소수점의 위치를 조정하여 수의 크기를 나타낸다. 

- Float(단정밀도): 32비트를 사용하여 부호는 1비트, 지수는 8비트, 가수는 23비트로 구성
장점: 단정밀도는 대부분의 일반적인 계산에 적합하다 
단점: 메모리 사용이 적고 연산 속도가 빠르다.
- Double(배정밀도): 64비트를 사용하여 부호는 1비트, 지수는 11비트, 가수는 52비트로 구성
장점: 배정밀도는 더 큰 범위의 값을 나타내며, 더 높은 정밀도가 필요한 계산에 적합하다. 
단점: 메모리 사용이 많고 연산 속도가 느립니다.
    
    ![Float / Double 비트 구성](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/86a4784d-528e-49b4-b064-3293b1a29efd/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-18_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.00.13.png)
    
    Float / Double 비트 구성
    

### Biased notation (바이어스된 표현법)

> 음수 지수는 숫자 정렬을 어렵게 만드는데 
이를 해결하기 위해서 계산하기 빠르게 하기 위한 지수 부분을 표현하는 방법 중 하나이다.
(음수지수를 계산하기 빠르게 하기 위한 표현방식)
> 

### 부동소수점 전용 하드웨어 지원

1. 부동소수점 연산은 대부분의 프로세서에서 하드웨어적으로 지원한다. 
이를 위해 부동소수점 전용 H/W가 사용되며, 이는 속도와 정확성 면에서 이점을 가진다.
2. a = a + (b * c)
**a = a + (b * c)와 같은 형태의 부동소수점 연산은 FMA(Fused Multiply-Add) 연산이라고 한다. 
이는 한 번의 연산으로 곱셈과 덧셈을 동시에 수행할 수 있어 성능 향상에 기여한다. 최신의 프로세서들은 이러한 FMA 연산을 하드웨어적으로 지원하며, 이를 사용하면 더욱 빠른 계산이 가능하다.
3. PowerPC, AMD SSE5, ARM NEON, Intel AVX에서 지원

### 서브워드 (데이터수준) 병렬성

> 큰 워드 내부에 병렬성이 있다고 할 때 이러한 확장을 서브워드 병렬성이라고 한다. (p. 253)
> 
- 128비트 덧셈기 내부를 분할하면 프로세서가 병렬성을 활용해서 다음을 동시에 연산 가능
    - 8비트 피연산자 16개
    - 16비트 피연산자 8개
    - 32비트 피연산자 4개
    - 64비트 연산자 2개
- 행렬 곱셈의 성능을 높이는 기술로 예를 들면 8개의 부동소수점 연산을 동시에 처리할 수 있다.
- 예시로 Nvidia Tensor Core 가 있다.

### FP16 & FP32

> 과학 연산 프로그램에서 2배 정밀도 부동 소수점은 과하고 32비트면 충분하다.
하지만 학습 과정에서 매우 작은 수를 다루기도 하기 때문에 계산과 메모리 측면에서 훨씬 효과적인 반 정밀도 16비트 사용할 수도 있다.
> 
- NVIDIA GPU의 Tensor 계산 성능이며 fp16기준 연산량을 가지고 있다.

# 프로세서

### 기본적인 MIPS

- 메모리 참조 명령어: lw (load doubleword), sw (store doubleword)
- 산술, 논리 명령어: add, sub, AND, OR, slt
- 조건부 분기 명령어: beq(branch equal), j(jump)

### 구현에 대한 개요 (p. 281)

1. 프로그램 카운터 (PC): 메모리 상의 현재 프로그램 실행 위치
2. 멀티플렉서(Mux: Multiplex): 다수의 근원지 중에서 하나를 선택하고 그것만을 목적지로 보내는 구성 요소
데이터 선택기(data selector)라고도 부른다.
3. 디멀티플렉서(Demux: De-multiplex): 멀티플렉서와 반대 개념으로 하나의 근원지를 다수로 보낸다.
    
    ![스크린샷 2023-04-25 오전 12.37.35.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aac04975-3847-4f4c-9288-35c59208757e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-25_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_12.37.35.png)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/46c7a0de-903f-4c36-a38a-34e34f06b7b6/Untitled.png)
    

## 데이터패스 (Datapath) 요소

> 컴퓨터 구성 요소 중 하나로, 중앙 처리 장치(CPU)의 주요 구성 요소 중 하나이다.
데이터패스는 연산을 수행하고 데이터를 처리하는 데 필요한 모든 하드웨어를 포함한다.
> 
- MIPS를 구현하는 데이터패스 요소는 조합 소자와 상태 소자 두 가지 종류의 논리 소자들로 구성된다.

### 조합 소자 (combinational element)

> 데이터 값에 대해 연산을 수행하는 소자로 출력이 현재 입력에 의해서만 결정된다.
> 
- AND, OR, NOT 게이트나 ALU 같은 연산형 소자이다.

### 상태 소자 (state element)

> 소자에 내부 기억 장소가 있으면 상태를 갖게 되고 이러한 소자를 상태 소자라고 한다.
컴퓨터 전원을 끄더라도 끄기 전 값을 상태 소자에 넣어주면 똑같은 상태에서 시작 가능.
> 
- 값 (0, 1)을 기억하는 상태를 가지는 소자
- 명령어 / 데이터 메모리, 레지스터 등이 상태 소자이다.
- 적어도 2개의 입력(기록할 데이터와 클럭)과 1개의 출력을 가진다.
- D 플립플롭: 논리적으로 가장 간단한 상태 소자 중 하나

### 논리회로 & 순차회로

- 논리회로: 조합 소자만으로 구성된 회로
- 순차회로: 상태를 포함하는 논리 구성 요소들
    - 레지스터: 데이터를 회로에 저장
    클럭 신호를 사용하여 저장된 값을 업데이트할 시기를 결정합니다.
    에지 트리거: Clk가 0에서 1로 변경될 때 업데이트
    - 쓰기 제어로 등록
    쓰기 제어 입력이 1인 경우 클록 에지에서만 업데이트
    추후 저장된 값이 필요할 때 사용

---

## 동기식 & 비동기식

HW에서의 의미: 클럭 공유 여부

SW에서의 의미: 함수를 호출하고 return 될 때까지 기다려야하는 여부

### 동기식 (synchronous)

> HW: 시스템의 작동에 사용되는 클럭(clock 시계) 신호를 기반으로 동작하는 것
SW: 어떤 작업이 다른 작업의 결과를 기다리는 경우
> 
- 하나의 메인보드 클럭이 CPU, GPU, 메모리, SSD, HDD로 들어감
- 서로 다른 클럭 속도는 분주(divide)되어 들어감
- 주로 짧은 거리에서 동작하고 신뢰도가 높다.
- 대표적으로 컴퓨터가 있다.

### 비동기식 (asynchronous)

> HW: 클럭 신호를 사용하지 않고, 요청과 응답 사이의 딜레이가 발생하는 것을 허용
SW: 요청과 응답이 동시에 발생하지 않고, 요청한 작업의 결과를 기다리지 않고 다른 작업을 수행 가능
> 
- 여러 시스템이 연결된 네트워크에서 사용한다.
- 주로 먼거리이기 때문에 신뢰도가 낮다.
- 받았는지 안받았는지(ACK/NACK)를 확인이 필요하다.
- 대표적으로 인터넷이 있다.

---

## 클러킹 방법론 (clocking methodology)

> 하드웨어를 예측 가능하기 위해 고안된 방법으로 신호를 읽고 쓰는 시점을 정의한다.
> 
- 클럭 신호와 쓰기 신호가 인가(신호가 논리적으로 참일 때)되어야 상태값 변경이 가능하다.
- 전제조건: 클럭이 한 사이클 이내에 모든 회로의 전파가 완료될 정도로 충분히 길어야 한다.

### 에지 구동 클러킹 (edge-triggerd clocking)

> 순차 논리 소자에 저장된 값은 클럭 에지에서만 바꿀 수 있다는 것을 의미한다.
> 
- Rising edge, falling dege 둘 중 하나에서만 동작하도록 설계
- 에지 구동 클러킹은 구성 요소가 동시에 작동하도록 동기화하고, 타이밍을 제어하여 순차적 실행을 가능하게 하는데 사용됩니다.