# 파이프 라이닝 (Pipe lining)

## 단일 사이클 데이터패스

1. 별도의 명령어 메모리와 데이터 메모리를 가진다.
2. 메모리를 별도로 가지면 저렴하다. (듀얼포트 메모리에 비해서)
3. 한 사이클에 명령어 메모리와 데이터 메모리를 동시에 접근 가능하다.

## 단순구현 데이터패스

- lw (Load Word): 메모리에서 데이터를 읽어와 레지스터에 저장합니다. lw 명령어는 메모리 주소와 읽어올 데이터를 지정하는 레지스터 번호를 사용합니다. 데이터를 읽어오는 과정은 다음과 같습니다.
    1. lw 명령어의 주소를 메모리에서 읽어옵니다.
    2. 메모리에서 읽어온 주소에 해당하는 데이터를 가져옵니다.
    3. 데이터를 레지스터에 저장합니다.
- sw (Store Word): 레지스터에 있는 데이터를 메모리에 저장합니다. sw 명령어는 메모리 주소와 저장할 데이터를 지정하는 레지스터 번호를 사용합니다. 데이터를 저장하는 과정은 다음과 같습니다.
    1. sw 명령어의 주소를 메모리에서 읽어옵니다.
    2. 메모리에서 읽어온 주소에 해당하는 위치에 데이터를 저장합니다.
- beq (Branch if Equal): 두 개의 레지스터 값이 같으면 지정된 주소로 분기합니다. beq 명령어는 비교할 두 레지스터 번호와 분기할 주소를 사용합니다. 분기하는 과정은 다음과 같습니다.
    1. 비교할 두 레지스터의 값을 가져옵니다.
    2. 값이 같은 경우 분기할 주소로 제어 흐름을 변경합니다.

---

## ALU 동작(연산 및 제어)

### ALUOps

> 제어 유닛에서 ALU에게 전달하는 2비트 정보이다.
연산 유형(예: 덧셈, 뺄셈, AND, OR 등)을 식별하는 정보와, 연산 대상(예: 레지스터, 즉 R-type 명령어에서의 rs, rt 필드)을 식별하는 정보가 포함된다.
> 

### funct 필드

> R-type 명령어에서 사용되며, ALUOp에 의해 연산 유형이 식별된 후에도 추가적인 연산 유형 정보를 제공한다. 
funct 필드는 6비트 정보로, R-type 명령어에서 사용되는 연산 유형(예: 덧셈, 뺄셈, AND, OR 등)을 식별한다.
따라서, funct 필드는 ALUOp와 함께 사용되어 해당 명령어가 수행할 연산 유형을 완전히 식별한다.
> 

### ALU 제어 신호

ALU는 명령어 종류에 따라 첫 다섯 가지 기능 중 하나를 수행하게 된다.

- Load, Store는 add (메모리 주소 계산)
워드 적재(Load), 워드 저장(Store) 명령어인 경우에는 메모리 주소를 계산하기 위한 덧셈을 하는 데 ALU를 사용한다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7d15b400-3552-4ff0-864c-a9842de6284c/Untitled.png)
    
- Branch는 subtract (같은지 비교를 위해)
- R-type은 funct 필드 (하위 6비트)의 값에 따라 동작
- funct 필드 + ALUOp (op코드의 2비트) → ALU 제어입력 (아래 이미지 첨부)
    
    R형식 명령어의 경우에는 명령어 하위 6비트의 funct 필드 값에 따라서 다섯가지 연산 중 하나를 수행하게 된다.
    명령어의 funct 필드와 2비트 제어 필드를 입력으로 갖는 제어 유닛을 만들어서 4비트 ALU 제어 입력을 발생시킨다. (ALU Op)
    

결론: ALUOp와 funct 필드는 제어 유닛이 명령어를 해석하고 ALU에게 전달할 연산 유형 정보를 제공한다. 
이를 토대로 ALU는 입력 데이터를 가져와 주어진 연산 유형에 맞게 연산을 수행하고 결과를 출력한다.

![ALUOp (4비트 ALU 제어 입력)](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9f5d5929-9dbd-4223-8f4d-e0631386e7d4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.36.47.png)

ALUOp (4비트 ALU 제어 입력)

![2비트 ALUOp 제어와 6비트 funct 필드를 사용한 입력표
2비트 ALUOp는 opcode에서 가져옴](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/398d13c3-8f1b-4413-a7e2-6b042e07146c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.37.48.png)

2비트 ALUOp 제어와 6비트 funct 필드를 사용한 입력표
2비트 ALUOp는 opcode에서 가져옴

![4비트 ALU 제어신호를 위한 진리표
ALU 제어신호를 위한 진리값](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2a69d328-800c-487a-81bd-bd97e0ecf3b8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.40.15.png)

4비트 ALU 제어신호를 위한 진리표
ALU 제어신호를 위한 진리값

---

## 주 제어 유닛의 설계

> funct 필드와 2비트 신호를 제어 입력으로 사용하는 ALU 말고 제어의 나머지 부분에 대한 설명이다.
명령어 필드들을 데이터패스에 연결하는 방법을 이해하기 위해서 세 가지 형식을 다시 살펴봐야한다.
> 

![세 가지 명령어의 종류는 두 가지 명령어 형식을 사용한다.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7fd38696-9310-4162-a8c1-771308a0b255/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.07.41.png)

세 가지 명령어의 종류는 두 가지 명령어 형식을 사용한다.

### R 형식 명령어 (R-type)

> 레지스터 간의 연산을 수행하는 명령어
ex) "add $t0, $t1, $t2"와 같은 명령어
> 
- 명령어 형식 opcode가 모두 0이다.
- 이 명령어들은 3개의 레지스터 피연산자 rs, rt, rd를 가진다.
rs, rt필드는 근원지 레지스터를 나타내고 rd는 목적지 레지스터를 나타낸다.
- ALU 기능은 funct 필드에서 표시되며 앞에서 설명한 ALU 제어 유닛에 의해 해독된다.
- 우리가 구현하는 R 형식 명령어는 add, sub, AND, OR, slt 이다.

### 적재 & 저장 명령어 (Load, Store)

> 메모리와 레지스터 간의 데이터 이동을 수행하는 명령어
ex) "lw $t0, 4($s0)"와 같은 명령어
> 
- 적재(opcode = 35)와 저장(opcode = 43) 명령어를 위한 명령어 형식이다.
- 레지스터 rs는 베이스 레지스터로서 16비트 주소 필드와 더해져서 메모리 주소를 만든다.
- 적재 명령어의 경우 rt는 적재된 값이 저장될 목적지 레지스터이다.
- 저장 명령어의 경우 rt는 근원지 레지스터이며 그 레지스터의 값은 메모리에 저장된다.

### 분기 명령어 (Branch)

> 조건에 따라 프로그램 카운터(PC)를 변경하여 분기를 수행하는 명령어
ex) "beq $t0, $t1, label"과 같은 명령어
> 
- 같을 시 분기(opcode = 4) 명령어를 위한 명령어 형식이다.
- 레지스터 rs와 rt는 같은지 비교할 근원지 레지스터이다.
- 16비트 주소 필드는 부호확장되고 자리이동된 후 PC + 4에 더해져서 분기 목적지 주소가 된다.

---

## 데이터패스에 필요한 모든 멀티플렉서와 제어선

![스크린샷 2023-04-23 오후 11.19.40.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d8db50fb-5783-4ecd-bbcd-affc5e68d418/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.19.40.png)

### 각 제어신호의 의미

> 이 명령어 필드들은 MIPS 아키텍처에서 사용되는 주요 제어 신호이다.
> 
- RegDest
    - 이 필드는 명령어에서 목적 레지스터(Register)를 결정한다.
    - 만약 이 필드가 0이면 rd필드가 Write Register 번호가 되고, 1이면 rt필드가 Write Register 번호가 된다.
- RegWrite
    - 이 필드는 레지스터에 값을 쓸지 말지를 결정한다.
    - 만약 이 필드가 1이면 Write data 값을 Write Register 번호에 쓰고, 0이면 쓰지 않는다.
- ALUSrc
    - 이 필드는 ALU 두 번째 입력을 결정합니다.
    - 만약 이 필드가 0이면 ALU의 두 번째 입력(오프랜드)은 Read Data 2가 된다.
    - 1이면 부호확장된 명령어의 하위 16비트값이 ALU의 두 번째 입력(오프랜드)으로 들어간다.
- PCSrc
    - 이 필드는 다음 PC 값을 결정한다.
    - 만약 이 필드가 0이면 PC에 4를 더해 다음 명령어의 주소값을 가져오고
    - 1이면 분기 목적지 주소값 새로운 PC값으로 가져온다.
- MemRead
    - 이 필드는 데이터메모리에서 값을 읽을지 말지를 결정한다.
    - 만약 이 필드가 1이면 데이터메모리의 Address 주소에 해당하는 값을 Read Data 출력으로 가져온다.
- MemWrite
    - 이 필드는 데이터메모리에 값을 쓸지 말지를 결정합니다.
    - 만약 이 필드가 1이면 Write Data 값을 데이터메모리의 Address 주소(값)에 기록한다.
- MemtoReg
    - 이 필드는 ALU 또는 데이터메모리 출력 중 어떤 값을 Write Data로 쓸지를 결정합니다.
    - 만약 이 필드가 0이면 ALU 출력값이 레지스터 Write Data 입력값으로 들어가고, 
    1이면 데이터메모리 출력값이 레지스터 Write Data 입력값으로 들어간다.

### 명령어 별 신호값 (마이크로 코드) ~~이거 몰라도 될 거 같은데..~~

![제어 신호들의 값은 명령어의 opcode 필드에 의해서만 결정된다.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6b4bc9b5-4f7e-4bbe-a4d2-aa8e81d4dcfc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.32.02.png)

제어 신호들의 값은 명령어의 opcode 필드에 의해서만 결정된다.

![스크린샷 2023-04-23 오후 11.39.03.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3bee11f4-1001-4c07-bfe9-40062f07f8b7/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.39.03.png)

## **R-type Instruction (add $t1, $t2, $t3)**

1. 명령어를 인출하고 PC를 증가시킨다.
2. 레지스터 파일에서 두 레지스터 $t2와 $t3를 읽는다.
동시에 주 제어 유닛은 제어선의 값들을 결정한다.
3. ALU에서 레지스터 파일에서 읽어 들인 값들에 대해 연산을 한다.
기능 코드(명령어의funct 필드인 비트 5:0)를 사용하여 ALU 제어 신호를 만든다.
4. ALU의 결과값을 레지스터 파일에 저장한다(쓴다)
명령어의 비트 15:11을 이용하여 목적지 레지스터($t1)을 선택한다.
- 명령어의 구성 (~~몰라도 될듯~~)
    - Opcode(6 bits) : 0으로 설정됩니다.
    - rs 필드(5 bits) : 사용하지 않습니다.
    - rt 필드(5 bits) : $t2 레지스터를 나타냅니다.
    - rd 필드(5 bits) : $t1 레지스터를 나타냅니다.
    - shamt 필드(5 bits) : 사용하지 않습니다.
    - funct 필드(6 bits) : 0x20으로 설정됩니다.
    
    따라서 해당 명령어의 비트 표현은 "000000 01010 01011 01001 00000 100000"이 됩니다. 
    
    이 명령어는 ALUOp 필드 값이 10(ADD)이고, RegDst 필드 값이 1($t1 레지스터)인 제어 신호를 생성하게 됩니다. 그리고 RegWrite 필드 값이 1이므로, 연산 결과값은 $t1 레지스터에 저장됩니다.
    

## **Load Instruction (lw $t1, offset($t2))**

1. 명령어를 명령어 메모리에서 인출하고 PC 값을 증가시킨다.
2. 레지스터 파일에서 레지스터 $t2를 읽는다.
3. ALU는 레지스터 파일에서 읽어 들인 값과 명령어의 하위 16비트(offset)를 부화학장한 값의 합을 구한다.
4. 이 합을 데이터 메모리 접근을 위한 주소로 사용한다.
5. 메모리 유닛에서 가져온 데이터를 레지스터 파일에 쓴다.
레지스터 ($t1)은 명령어의 비트 20:16이 지정한다.

## **Branch on equal instruction (beq $t1, $t2, offset)**

1. 명령어를 명령어 메모리에서 인출하고 PC 값을 증가시킨다.
2. 레지스터 파일에서 두 레지스터 $t1과 $t2를 읽는다.
3. ALU는 레지스터 파일에서 읽어 들인 값들에 대해 뺄셈을 한다.
명령어의 하위 16비트(offset)를 부호확장한 후 2비트 왼쪽 자리이동한 값에다 PC+4 값을 더한다. 
이 값이 목적지 주소이다.
4. 어떤 덧셈기의 결과를 PC에 저장할지 ALU의 Zero 출력을 이용하여 결정한다.

---

## Jump 명령어 추가

> Jump 명령어는 MIPS에서 사용되는 분기(branch) 명령어 중 하나이다.
프로그램 카운터(PC) 값을 변경하여 다른 주소로 분기하는 역할이다.
> 
- Jump는 word 주소 기반이다.
- PC를 이전 PC의 4비트 + 26비트 jump 주소 + 00으로 세팅한다.
- Opcode에서 추가 제어 신호가 필요하다.