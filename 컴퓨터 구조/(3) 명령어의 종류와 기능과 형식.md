# 어셈블리 명령어
## 명령어 형태
1. Opcode-only 명령어
    - Opcode로만 이루어진 명령어로, 피연산자를 필요로 하지 않는다.
    - 예 : `halt`, `nop`
2. Operand(s)-only 명령어
   - 피연산자만으로 이루어진 명령어로, 연산코드를 필요로 하지 않는다.
   - 예 : `move $s1, $s2, $s3`, `beq $t0, $t1, label`
3. Opcode + Operand(s) 명령어
   - Opcode와 피연산자들이 함께 이루어진 명령어
   - 예: `add $s1, $s2, $s3`, `beq $t0, $t1, label`
  
## 피연산자(Operand) 명령어 개수
- 0개 -> 대부분 컴퓨터 내부 동작과 관련된 제어 명령어 - NOP, HLT
- 1개 -> 대부분이 메모리나 레지스터에서 값을 읽거나 쓰는 데이터 전송 명령어 - MOV, INC, DEC
- 2개 -> 대부분이 연산 명령어 - ADD, SUB, AND, OR
- 3개 -> 대부분 복잡한 연산 수행 - MUL, DIV 등

# Word / Word Alignment
> 워드 : 컴퓨터 구조에서 데이터를 처리하는 단위
> CPU가 한 사이클/틱에 처리하는 데이터 크기
- 보통 8 / 16 / 32 비트 중에 하나
- 현재 데스크탑 & 모바일은 64비트가 주류

## 뱅크(bank)
> 데이터 출력 핀의 개수와 워드 값을 맞추기 위한 개념
메모리에서 읽어오는 데이터는 워드 단위로 읽어오게 되는데, 뱅크의 개수를 늘리면 출력 핀의 개수도 늘어나기 때문에 워드 값을 맞출 수 있다.
ex) 한개의 메모리의 출력이 8비트인 경우 32비트 워드값과 맞추기 위해서는 램 4개가 필요하다.

## 채널(channel)
> 메모리 컨트롤러 워드값을 CPU보다 크게 만들어 메모리 대역폭을 늘리는 기술
CPU가 메모리에 접근할 때 메모리 컨트롤러를 통해 메모리와 통신을 하게 되는데, 이 때 메모리 컨트롤러와 메모리 사이에 채널이 있어서 데이터 전송이 이루어진다.
듀얼채널 / 트리플채널 / 쿼드 채널 : 램 2 / 3 / 4 개를 꽂는 것이 램 1개를 쓰는 것보다 메모리 대역폭이 크다.

## 정렬 제약
> 데이터가 메모리 상에서 적절한 바이트 경계에 위치해야 한다는 제약
> 데이터를 워드 크기(여기서는 4바이트)에 맞춰 정렬해서 저장하는 기법

- 컴퓨터는 3바이트 컬러값(24비트)를 사용해서 1,600만가지 색상 표현
  - 3 바이트는 워드값(4바이트)과 틀림
  - 속도(1바이트 저장용량을 포기) vs 저장 효율
  - 버리는 1바이트를 다른 용도로 사용
    - 투명도 / 불투명도

# MIP
> CPU가 1초동안 처리할 수 있는 명령어 수를 나타내는 지표
> 컴퓨터 시스템의 처리 성능을 측정하는 데 사용되는 대표적인 지표 중 하나이다.
## MIP(32 비트 버전의 특징)
- MIPS 명령어는 오퍼랜드가 3 개인 경우가 대부분 -> 하드웨어가 단순해진다.
- MIPS는 레지스터가 32개
- MIPS는 메모리를 최대 1GB 지원
- MIPS의 워드 값은 4바이트
- 숫자의 signed / unsigned 지원
- 메모리 word(4바이트) / half word(2바이트) / byte 접근 지원
## MIPS의 주소 지정 방식
- 일반 분기의 주소 필드는 26비트(메모리는 1GB까지 지원)
  - 하나의 프로그램은 256MB 이상을 지원하지 않는다.
- 조건부 분기는 주소필드는 16비트(PC 값에 16비트 옵셋을 통한 간접지정)
- 예전의 C의 FAR 포인터 / NEAR 포인터 개념(segment / 64KB)
  
# 리틀 엔디안 / 빅엔디안
> 컴퓨터에서 바이트 단위 데이터를 표현하는 방식 중 하나(메모리의 워드 값을 어떤 값을 쓰는가에 따른 분류)

## 리틀 엔디안
> 바이트의 오른쪽 끝부터 데이터를 저장하는 방식
- 인텔 x86에서 사용
- 32비트 정수 0x12345678을 메모리에 저장한다면, 78이 가장 작은 주소에, 56이 다음주소에, 12가 가장 큰 주소에 저장된다. 

## 빅 엔디안
> 바이트의 왼쪽 끝부터 데이터를 저장하는 방식
- MIPS와 네트워크 프로토콜 등에서 주로 사용
- 32비트 정수 0x12345678을 메모리에 저장한다면, 12가 가장 작은 주소에, 34가 다음 주소에, 56이 그 다음 주소에, 78이 가장 큰 주소에 저장된다.

# 레지스터 & 메모리
## 레지스터
> CPU 내부에 있는 속도가 매우 빠른 기억 장치
- 장점 : 데이터를 레지스터에 저장하면 접근속도가 매우 빠르기 때문에 CPU의 성능을 향상시킬 수 있다.
- 매우 한정적인 용량을 갖고 있기 때문에, 저장할 수 있는 데이터의 양이 제한적이다.
  
## 메모리
> 대용량의 데이터를 저장할 수 있는 주 기억 장치
- 장점 : 많은 데이터를 저장할 수 있다.
- 단점 : 레지스터보다는 느리다.

# 함수(프로시져) 지원
> 함수는 리턴 값을 가지고 프로시져와 서브 루틴 리턴 값을 가지지 않는다.

## jal (Jump and Link)
> MIPS 명령어 중 하나로, 함수 호출 시 사용되는 분기 명령어
- 함수의 복귀주소(return address)를 가진다.
- $ra 레지스터에 저장된 값을 PC 레지스터에 저장하여, 함수 호출 이전의 명령어를 실행하도록 한다.
    -> 호출한 함수로부터 반환된 후에 원래의 코드 흐름으로 돌아가는 것이 가능
- Activation Recode에 저장된 호출 정보와 변수를 사용하여 이전 상태로 복원한다.

## 스택 & 힙
- 함수의 인자 / 리턴 값은 스택에 저장한다.
- 전역 변수 같이 상대적으로 오래 남는 값은 힙은 저장된다.

## 메모리 누출
- C, C++ : 할당 받은 메모리를 돌려받지 않고 리턴한다. 
  - 버퍼오버플로우 해킹에 취약하다.
  - 버퍼 오버 플로우 : 버퍼의 크기를 벗어나는 데이터를 입력할 때 발생하는 보안 취약점
  - 버퍼오버플로우 원인 : 보통 사용자로부터 입력을 받을 때, 입력된 데이터의 크기를 체크하지 않고 그대로 버퍼에 저장하는 경우
  - 해결 : 버퍼 오버 플로우를 예방하기 위해서는 입력된 데이터의 크기를 체크하고, 버퍼의 크기를 벗어나는 데이터가 들어올 경우 이를 걸러내는 방법이 있다.
- Java, C# : Garbage Collection이 있다.

# 문자(문자열)
## ASCII
- 1바이트를 사용
- 한글은 2바이트로 표현(완성형)

## 문자열
- 문자열 앞에 길이 표시
- 구조체 형태로 길이 / 문자열 표현
- 

