# 노이만구조 컴퓨터

> 명령어 메모리와 데이터 메모리가 같은 메모리 공간을 공유
> 
- 존 폰 노이만이 제안
- 메모리에 적재된 프로그램이 명령어/데이터가 혼재되는 형태
    - 반드시 시작주소부터 프로그램이 실행되어야 함
    - 명령어와 데이터가 위치에 따라 의미가 달라짐

# 하버드구조 컴퓨터

> 명령어 메모리와 데이터 메모리가 물리적으로 분리
> 
- 하버드 마크1에서 적용된 구조
- 프로그램 메모리와 데이터 메모리가 분리되어 저장됨
    - 메모리 주소에 따라 같은 데이터가 의미가 달라지지 않음
- 성능 면에서 장점을 가지지만 비교적 구조가 복잡

## 현재의 컴퓨터 구조

- 메모리는 노이만 구조, 캐시는 하버드 구조를 채택함
    - 메모리는 통합해서 하나로 관리
    - 캐시는 명령어 캐시 + 데이터 캐시로 분리해서 관리

---

# 컴퓨터 언어

## 저수준 언어

> 기계어 / 어셈블리
> 
- OPCODE(MOV) / Operand(EAX,1)

## 고수준 언어

> JAVA / Python / Javascript
> 
- H/W에 대한 접근은 거의 안 됨

## 중수준 언어

> C
> 
- 하드웨어에 대한 접근을 어느 정도 허용
    - 양날의 검(성능 vs 안정성)
- 현재는 Go라는 언어가 명맥을 이어가고 있음
    - 클라우드 / 블럭체인에서 많이 사용

# SW와 HW의 분화

- 하드웨어를 제어하는 간단한 역할만 하다가 지금은 독립
- ALU / FPU / 배럴 쉬프터
    - 더하기 / 곱하기 등의 연산 최적화
- DSP / 가속기
    - 동영상 인코딩/디코딩 등 특정한 목적의 HW를 추가해 활용

---

# 클럭스피드 / 워드 / 사이클

클럭 스피드는 CPU의 속도를 나타내고, 워드는 한 번에 처리할 수 있는 데이터의 크기를, 사이클은 CPU가 명령어를 처리하는 데 필요한 최소한의 시간 단위를 나타냅니다.

## 클럭 스피드

CPU의 동작 속도를 나타내는 척도입니다. 이는 초당 몇 번의 클럭 사이클(Clock Cycle)을 수행할 수 있는지를 나타내며, Hz 단위로 표기됩니다. 예를 들어, 3 GHz 클럭 스피드는 1초당 30억 번의 클럭 사이클을 수행할 수 있다는 것을 의미합니다.

- CPU의 동작 속도를 나타내는 척도
- 4.9Hz: 1초에 49억 번 사이클을 발생시킴

## 워드

워드(Word)는 컴퓨터에서 한 번에 처리할 수 있는 데이터의 크기를 나타내는 단위입니다. 이는 보통 CPU가 한 번에 처리할 수 있는 데이터의 최대 크기를 의미하며, 비트(Bit) 단위로 표기됩니다. 예를 들어, 32비트 워드는 한 번에 32비트의 데이터를 처리할 수 있습니다.

- CPU가 한 번에 처리할 수 있는 데이터 처리량
- 8비트 / 16비트 / 32비트 …

## 사이클

사이클(Cycle)은 CPU가 명령어를 수행하는 데 필요한 최소한의 시간 단위입니다. CPU가 한 번의 명령어를 수행하는 데 필요한 사이클 수는 명령어마다 다르며, 이는 CPU의 아키텍처에 따라서 결정됩니다. 일반적으로 CPU는 사이클 수행을 완료할 때마다 클럭 신호를 보내어 다음 사이클을 수행하도록 합니다.

## 실제 처리량 = 워드 * 사이클 수

실제 처리량(Throughput/Bandwidth)은 단위 시간당 처리할 수 있는 데이터의 양을 나타내는 지표입니다. 이는 워드 크기와 사이클 수(클럭 사이클)를 곱하여 계산할 수 있습니다.

예를 들어, 32비트 워드 크기를 가진 CPU가 2.5 GHz의 클럭 스피드로 동작한다고 가정해봅시다. 이 경우, CPU는 1초당 25억 개의 클럭 사이클을 수행할 수 있습니다. 만약 CPU가 한 번의 명령어를 수행하는 데 4개의 사이클이 필요하다고 가정한다면, 이 CPU는 1초당 6.25억 개의 명령어를 수행할 수 있습니다.

이를 워드 크기와 함께 고려하여 계산해보면, 32비트 워드 크기를 가진 CPU는 한 번에 32비트(4바이트)의 데이터를 처리할 수 있습니다. 따라서 위의 예에서, CPU는 1초당 6.25억 개의 명령어를 수행하며, 각 명령어는 4바이트의 데이터를 처리할 수 있습니다. 이를 곱하여 계산하면, CPU의 실제 처리량은 25억 * 4바이트 = 100Gbps가 됩니다.

---

# CPU(중앙처리장치) 를 설계하는 방식

CISC는 명령어가 복잡하지만 프로그래머가 작성하는 코드를 짧게 만들어준다. 

RISC는 명령어가 간단하지만 성능이 우수하다.

## CISC(Complex Instruction Set Computer)

CISC는 복잡한 명령어 세트를 가진 아키텍처로, 하나의 명령어에서 여러 개의 동작을 수행할 수 있습니다. 예를 들면, 메모리에서 데이터를 읽고 동시에 연산을 수행하고, 그 결과를 메모리에 쓰는 등의 작업을 한 번에 수행할 수 있습니다. 이는 프로그래머가 작성하는 코드를 짧게 만들어줍니다. 그러나 이러한 복잡한 명령어를 실행하는 데에는 많은 하드웨어 자원이 필요합니다. 이로 인해 CISC 프로세서는 RISC 프로세서보다 느릴 수 있습니다.

- 복잡하고 많은 종류의 명령어와 주소 지정 모드를 사용한다.
- 가변 길이 명령어 형식이다.
- 100개 ~ 250개 정도의 많은 명령어를 가지고 있어 설계가 어렵다.
- 마이크로 프로그래밍(S/W) 제어 방식이다.
- 명령어가 S/W적이므로 호환성이 좋다.
- 명령어를 해석한 후에 명령어를 실행한다.
- 컴파일 과정이 쉽고, 호환성이 좋다는 장점이 있지만 속도가 느리다.

---

<컴구 ppt 설명>

- 명령어마다 실행하는 시간이 다름
    - 명령어마다 간단한 명령어는 1 사이클에서 복잡한 명령어는 4~8사이클이 필요
- 대표적인 아키텍처
    - x86/x86-64

## RISC(Reduced Instruction Set Computer)

RISC는 단순한 명령어 세트를 가진 아키텍처로, 하나의 명령어에서 한 개의 동작만을 수행할 수 있습니다. 이는 하나의 명령어를 실행하는 데 필요한 하드웨어 자원이 적습니다. 그러나 이는 더 많은 명령어를 실행해야 하는 경우에는 코드가 길어지고, 이로 인해 성능 저하가 발생할 수 있습니다.

- 간단하고 적은 종류의 명령어와 주소 지정 모드를 사용한다.
- 고정 길이 명령어 형식이다.
- CISC에 비해 명령어 수가 적다.
- 하드와이어드(논리 회로를 이용한 하드웨어)적 제어 방식이다.
- 명령어가 하드웨어적이므로 호환성이 낮다.
- 명령어의 길이가 미리 정해져 있으므로 해석 속도가 빠르다.

---

<컴구 ppt 설명>

- 명령어마다 실행하는 시간을 동일하게 만들고 복잡한 연산은 조합해서 가능하도록
- 대표적인 아키텍처
    - MIPS / ARM / RISC-V/ …
- 현재 CPU의 주류 트렌드
    - 인텔도 겉만 CISC지만 실제로 내부구조는 거의 RISC 구조임
        - 파이프라인 / 슈퍼 스케일러 / …

# 컴퓨터 시스템의 구현 개념

## 프로그래밍

> 일반적인 의미의 프로그래밍(고수준 ~ 저수준 언어로 코드 작성
> 

프로그래밍은 컴퓨터 프로그램을 작성하는 것으로, 일련의 명령문을 작성하여 컴퓨터가 실행할 수 있는 명령어 코드로 변환하는 과정입니다. 프로그래밍 언어에는 여러 가지가 있으며, 대표적으로 C, Java, Python 등이 있습니다. 이러한 언어를 사용하여 소프트웨어를 개발하고, 이를 컴파일하여 실행 가능한 형태로 만듭니다.

## 마이크로 프로그래밍

마이크로 프로그래밍은 **컴퓨터 시스템의 하드웨어를 제어하기 위해 사용되는 프로그램**을 작성하는 것입니다. 이 프로그램은 CPU의 제어신호를 생성하는 작은 명령어 세트인 마이크로 명령어(Microinstruction)를 사용하여 작성됩니다. 마이크로 명령어는 CPU의 동작 방식과 관련된 저수준 명령어로, CPU의 제어신호를 생성하고 명령어의 실행 순서를 조정하는 역할을 합니다. 이러한 마이크로 프로그램은 하드웨어의 성능을 최적화하고 명령어 실행의 효율성을 향상시키는 데 중요한 역할을 합니다.

- ADD EAX, 10(EAX 레지스터의 내용에 10을 더해라)라는 어셈블리 코드를 실행하도록 컴퓨터구조의 각 세부노드(CPU/레지스터 등)를 조정(일종의 코딩)
    - ALU를 Adder 모드로 만들고 첫 번째 오퍼랜드를 EAX로 하고 두 번째 오퍼랜드에 10을 넣어 결과를 다시 EAX로 저장해라
- 주로 펌웨어 / 바이오스 / CPU 안에 저장되어 있음
- 저작권 보호대상

---

# CPU의 핵심 구성 요소

ALU와 FPU는 CPU의 핵심적인 구성요소이며, 배럴 쉬프터는 비트 연산이 필요한 경우에 필수적으로 사용됩니다.

## ALU (산술논리 연산장치)

컴퓨터에서 산술 연산(덧셈, 뺄셈, 곱셈, 나눗셈 등)과 논리 연산(AND, OR, NOT, XOR 등)을 수행하는 장치입니다. ALU는 레지스터에서 입력값을 받아 연산을 수행하고, 결과값을 다른 레지스터에 저장합니다. 예를 들어, 5와 3을 더하는 경우 ALU는 5와 3을 받아서 8을 계산하고, 이를 다른 레지스터에 저장합니다.

## FPU (부동소수점 연산장치)

FPU(부동소수점연산장치)는 컴퓨터에서 부동소수점 연산(부동소수점 덧셈, 뺄셈, 곱셈, 나눗셈 등)을 수행하는 장치입니다. 부동소수점은 실수를 표현하기 위한 방식으로, 정수와는 다르게 소수점의 위치가 고정되어 있지 않습니다. 따라서 FPU는 부동소수점 연산을 위한 별도의 연산 장치로 구성되어 있습니다. 예를 들어, 3.5와 2.4를 더하는 경우 FPU는 이를 받아서 5.9를 계산하고, 이를 다른 레지스터에 저장합니다.

## 배럴 쉬프터 (Barrel Shifter)

배럴 쉬프터(Barrel Shifter)는 컴퓨터에서 비트 연산(시프트, 회전, 논리 연산 등)을 수행하는 장치입니다. 배럴 쉬프터는 입력값과 시프트 수를 받아서, 입력값을 해당 수만큼 시프트하거나 회전시키고, 논리 연산을 수행합니다. 예를 들어, 1100을  2비트 오른쪽으로 시프트하는 경우 배럴 쉬프터는 이를 받아서 0011을 계산하고, 이를 다른 레지스터에 저장합니다.